diff --git a/.gitignore b/.gitignore
index 8008b20..f5a8b48 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,9 @@
 *.o
+objs
 webserv
-.idea
+.clang-format
 .vscode
+.DS_Store
 cmake-build-debug
-.clang-format
 CMakeLists.txt
-objs
-.DS_Store
\ No newline at end of file
+.idea
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 7d9a7aa..cf12546 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,8 @@ RMFLAGS		= -f
 OUT_DIR		= objs
 SRC_DIR		= srcs
 FILE		= Client ClientManager ConfigFunctions ConfigParser Event Location Message Http/Handler/Handler Http/Handler/HttpStatusCodes \
-				Http/Handler/ErrorHandler ResponseMessage Server ServerManager Http/HttpRequestManager Http/Handler/StaticHandler Http/Handler/DynamicHandler main
+				Http/Handler/ErrorHandler ResponseMessage Server ServerManager Http/HttpRequestManager \
+				Http/Handler/StaticHandler Http/Handler/DynamicHandler Http/Handler/DeleteHandler main
 OBJECTS		= $(addprefix $(OUT_DIR)/, $(addsuffix .o, $(FILE)))
 
 # Compile rules
diff --git a/YoupiBanane/Yeah/not_happy.bad_extension b/YoupiBanane/Yeah/not_happy.bad_extension
new file mode 100644
index 0000000..e69de29
diff --git a/YoupiBanane/nop/other.pouic b/YoupiBanane/nop/other.pouic
new file mode 100644
index 0000000..e69de29
diff --git a/YoupiBanane/nop/youpi.bad_extension b/YoupiBanane/nop/youpi.bad_extension
new file mode 100644
index 0000000..e69de29
diff --git a/YoupiBanane/youpi.bad_extension b/YoupiBanane/youpi.bad_extension
new file mode 100644
index 0000000..2e65efe
--- /dev/null
+++ b/YoupiBanane/youpi.bad_extension
@@ -0,0 +1 @@
+a
\ No newline at end of file
diff --git a/YoupiBanane/youpi.bla b/YoupiBanane/youpi.bla
new file mode 100644
index 0000000..e69de29
diff --git a/cgi_tester b/cgi_tester
new file mode 100755
index 0000000..72def28
Binary files /dev/null and b/cgi_tester differ
diff --git a/config/default.conf b/config/default.conf
index a3976e2..1cecd0c 100644
--- a/config/default.conf
+++ b/config/default.conf
@@ -21,16 +21,30 @@ server {
 server {
     listen      80 ;
     server_name localhost ;
+    error_page  403 404 405 40x.html ;
 
     location / {
         allow_method GET POST ;
         root   ./www ;
         index  index.html index.htm ;
     }
+
+    location /directory {
+        allow_method GET ;
+        root   ./YoupiBanane ;
+        index  youpi.bad_extension ;
+    }
+
+    location /put_test {
+        allow_method PUT ;
+        root   ./YoupiBanane ;
+        index  youpi.bad_extension ;
+    }
+
     location /soulee {
         allow_method GET POST ;
-        root   ./html2 ;
-        index  index2.html ;
+        root   ./www ;
+        index  index.html ;
         autoindex   on ;
     }
 
diff --git a/error_pages/404.html b/error_pages/404.html
deleted file mode 100644
index d9f18f5..0000000
--- a/error_pages/404.html
+++ /dev/null
@@ -1 +0,0 @@
-<h1>404 Not found</h1>
\ No newline at end of file
diff --git a/error_pages/40x.html b/error_pages/40x.html
new file mode 100644
index 0000000..d14703b
--- /dev/null
+++ b/error_pages/40x.html
@@ -0,0 +1,5 @@
+<html>
+<head>
+    <title>404 Not Found</title>
+</head>
+</html>
\ No newline at end of file
diff --git a/error_pages/50x.html b/error_pages/50x.html
new file mode 100644
index 0000000..2b49c8f
--- /dev/null
+++ b/error_pages/50x.html
@@ -0,0 +1,5 @@
+<html>
+<head>
+    <title>405 Method Not Allowed</title>
+</head>
+</html>
\ No newline at end of file
diff --git a/html2/index5.html b/html2/index5.html
deleted file mode 100755
index 76ef2d1..0000000
--- a/html2/index5.html
+++ /dev/null
@@ -1,2 +0,0 @@
-<h1>this is for test2 INDEX 5</h1>
-<h2> -- gyopark -- </h2>
\ No newline at end of file
diff --git a/srcs/Client.cpp b/srcs/Client.cpp
index 8cd00b2..26d05cf 100644
--- a/srcs/Client.cpp
+++ b/srcs/Client.cpp
@@ -67,12 +67,13 @@ bool Client::readEventProcess(void) // RUN 5
 		// 메시지 처리하여 버퍼에 입력해야함.
 		// events.changeEvents(ident, EVFILT_WRITE, EV_ENABLE, 0, 0, NULL);
 		HttpRequest&	request = this->httpRequestManager.getRequest();
+		std::cout << BOLDGREEN << "URI : " << request.uri << RESET << '\n';
 
 		httpRequestManager.SetHandler(*this);
 		httpRequestManager.DynamicOpenFd(*this);
 		httpRequestManager.SendReqtoEvent(*this);
 		httpRequestManager.DynamicRunCgi(*this);
-		std::cout << BOLDCYAN << " -- SUCCESSFULLY SEND MESSAGE -- \n\n";
+		std::cout << BOLDCYAN << " -- SUCCESSFULLY SEND MESSAGE -- \n\n" << RESET;
 		parseState = READY;
 		return true;
 	}
@@ -167,7 +168,7 @@ void Client::readHeader(const char* buffer)
 				return;
 			}
 			else if (req.headers.find("content-length") == req.headers.end() &&
-					 (req.method == "GET" || req.method == "DELETE"))
+					 (req.method == "GET" || req.method == "DELETE" || req.method == "HEAD" || req.method == "POST"))
 			{
 				parseState = DONE;
 				return;
diff --git a/srcs/Http/Handler/DeleteHandler.cpp b/srcs/Http/Handler/DeleteHandler.cpp
new file mode 100644
index 0000000..128d596
--- /dev/null
+++ b/srcs/Http/Handler/DeleteHandler.cpp
@@ -0,0 +1,27 @@
+#include "DeleteHandler.hpp"
+#include "../../Client.hpp"
+
+std::vector<unsigned char>	DeleteHandler::handle(Client &client) const
+{
+	HttpRequest&	request = client.httpRequestManager.getRequest();
+    const char *path = request.path.c_str();
+    std::map<std::string, std::string>  headers;
+    std::vector<unsigned char> emptyBody;
+
+	if (std::remove(path) == 0)
+	 {
+		std::cout << "DELETE SUCCESS\n" << RESET;
+        headers["Connection"] = "close";
+	}
+	else
+	{
+        std::cout << "DELETE FAILED\n" << RESET;
+        return ErrorHandler::handle(client, 404);
+	}
+    return BuildResponse(200, headers, emptyBody);
+}
+
+void DeleteHandler::sendReqtoDelete(Client &client)
+{
+	client.sendBuffer = handle(client);
+}
diff --git a/srcs/Http/Handler/DeleteHandler.hpp b/srcs/Http/Handler/DeleteHandler.hpp
new file mode 100644
index 0000000..29bc8d1
--- /dev/null
+++ b/srcs/Http/Handler/DeleteHandler.hpp
@@ -0,0 +1,10 @@
+#pragma once
+
+#include "Handler.hpp"
+
+class DeleteHandler : public Handler
+{
+	public:
+		std::vector<unsigned char>	handle(Client &client) const;
+		void sendReqtoDelete(Client &client);
+};
diff --git a/srcs/Http/Handler/DynamicHandler.cpp b/srcs/Http/Handler/DynamicHandler.cpp
index 4e0500a..481e0d2 100644
--- a/srcs/Http/Handler/DynamicHandler.cpp
+++ b/srcs/Http/Handler/DynamicHandler.cpp
@@ -43,15 +43,23 @@ void DynamicHandler::RunCgi(Client& client)
 		close(request.pipe_fd_back[1]); // Close unused write end in parent
 		close(request.pipe_fd[1]); // Close unused read end
 		close(request.pipe_fd_back[0]); // Close unused write end in parent
+		
+		// TODO MAX BODY SIZE
+		// if (request.body.size() > 100)
+		// 	request.body.resize(100); // max body size
 
 		int size = request.body.size();
 		std::string size_str = std::to_string(size); //c++ 11 
 		const char *size_cstr = size_str.c_str();
 
-		std::cout << request.cgi_args << std::endl;
 		setenv("QUERY_STRING", request.cgi_args.c_str(), 1);
 		setenv("REQUEST_METHOD", request.method.c_str(), 1);
 		setenv("CONTENT_LENGTH", size_cstr, 1);
+		setenv("SERVER_PROTOCOL", SERVER_HTTP_VERSION, 1);
+		setenv("PATH_INFO", request.cgi_path_info.c_str(), 1);
+
+		if (request.uri.find(".bla") != std::string::npos)
+			request.path = "./cgi_tester";
 
 		if (execve(request.path.c_str(), NULL, environ) == -1)
 		{
diff --git a/srcs/Http/Handler/ErrorHandler.cpp b/srcs/Http/Handler/ErrorHandler.cpp
index d805dc7..ce7e8c5 100644
--- a/srcs/Http/Handler/ErrorHandler.cpp
+++ b/srcs/Http/Handler/ErrorHandler.cpp
@@ -1,14 +1,51 @@
 #include "ErrorHandler.hpp"
+#include "../../Client.hpp"
 
-std::vector<unsigned char>	ErrorHandler::handler(int status_code)
+std::vector<unsigned char>	ErrorHandler::handle(Client &client, int status_code)
 {
 	std::vector<unsigned char>			body;
 	std::map<std::string, std::string>	headers;
+	std::string							file_name;
+	bool								find_flag = false;
 
-	// TODO: Config에서 맞게 읽어도록 하기
-	std::string	file_name = "./error_pages/404.html";
+	// std::vector<int>::const_iterator it2;
+	// std::map<std::vector<int>, std::string>::const_iterator it1 = client.getServer()->getErrorPage().begin();
+	// for (; it1 != client.getServer()->getErrorPage().end(); it1++)
+	// {
+	// 	it2 = it1->first.begin();
+	// 	for (; it2 != it1->first.end(); it2++)
+	// 	{
+	// 		std::cout << *it2 << std::endl;
+	// 		if (*it2 == status_code)
+	// 		{
+	// 			std::cout << "FOUND DEFAULT" << std::endl;
+	// 			find_flag = true;
+	// 			break;
+	// 		}
+	// 	}
+	// 	if (find_flag)
+	// 		break;
+	// }
+	// if (find_flag)
+	// 	file_name = it1->second;
+	// else
+	std::map<std::vector<int>, std::string>::const_iterator it1 = client.getServer()->getErrorPage().begin();
+	for (;it1 != client.getServer()->getErrorPage().end(); it1++)
+	{
+		for (std::vector<int>::const_iterator it2 = it1->first.begin(); it2 != it1->first.end(); it2++)
+		{
+			std::cout << "it2 : " << *it2 << " ";
+		}
+		std::cout << "it1 : " << it1->second << std::endl;
+	}
+		file_name = "./error_pages/40x.html";
 	body = ReadStaticFile(file_name);
 	headers["Connection"] = "close";
 	headers["Content-Type"] = GetFileType(file_name);
 	return BuildResponse(status_code, headers, body);
 }
+
+std::vector<unsigned char>	ErrorHandler::handle(Client& client)
+{
+	static_cast<void>(client);
+}
diff --git a/srcs/Http/Handler/ErrorHandler.hpp b/srcs/Http/Handler/ErrorHandler.hpp
index 0bd2183..bc9411f 100644
--- a/srcs/Http/Handler/ErrorHandler.hpp
+++ b/srcs/Http/Handler/ErrorHandler.hpp
@@ -7,5 +7,6 @@ class ErrorHandler : public Handler
 	private:
 
 	public:
-		static std::vector<unsigned char>	handler(int status_code);
+		static std::vector<unsigned char>	handle(Client &client, int status_code);
+		std::vector<unsigned char>	handle(Client& client);
 };
diff --git a/srcs/Http/Handler/Handler.cpp b/srcs/Http/Handler/Handler.cpp
index 89e3130..5c84852 100644
--- a/srcs/Http/Handler/Handler.cpp
+++ b/srcs/Http/Handler/Handler.cpp
@@ -53,13 +53,28 @@ std::vector<unsigned char>	Handler::BuildHeader(int status_code, std::map<std::s
 	return stou(ss);
 }
 
-std::vector<unsigned char>	Handler::BuildResponse(int status_code, std::map<std::string, std::string>& headers, std::vector<unsigned char>& body)
+std::vector<unsigned char>	Handler::BuildResponse(int status_code, std::map<std::string, std::string>& headers, std::vector<unsigned char>& body, bool is_cgi)
 {
 	std::vector<unsigned char>	response;
-
-	headers["Content-Length"] = itos(body.size());
-	response = BuildHeader(status_code, headers);
+	std::string	body_str(body.begin(), body.end());
+	std::cout << "CODE : " << status_code << "\n\n";
+	
+	if (is_cgi)
+	{
+		size_t	pos = body_str.find("\r\n\r\n");
+		headers["Content-Length"] = itos(body.size() - pos - 4);
+		response = BuildHeader(status_code, headers, false);
+	}
+	else
+	{
+		headers["Content-Length"] = itos(body.size());
+		response = BuildHeader(status_code, headers, true);
+	}
 	response.insert(response.end(), body.begin(), body.end());
+
+	for (size_t i = 0; i < response.size(); i++)
+		std::cout << response[i];
+	std::cout << '\n';
 	return response;
 }
 
@@ -89,7 +104,7 @@ bool	Handler::IsRegularFile(std::string path)
 }
 
 // Check permission file is readable
-bool	Handler::IsFileReadble(std::string path)
+bool	Handler::IsFileReadable(std::string path)
 {	
 	struct stat	buf;
 
@@ -123,16 +138,22 @@ std::vector<unsigned char>	Handler::ReadStaticFile(std::string& file_name)
 	return buffer;
 }
 
-std::vector<unsigned char>	Handler::ServeStatic(std::string& path)
+std::vector<unsigned char>	Handler::ServeStatic(Client& client, std::string& path, std::string method)
 {
 	std::vector<unsigned char>			body;
 	std::map<std::string, std::string>	headers;
 
 	if (!IsFileExist(path))
-		return ErrorHandler::handler(404);
-	if (!IsRegularFile(path) || !IsFileReadble(path))
-		return ErrorHandler::handler(403);
-	body = ReadStaticFile(path);
+		return ErrorHandler::handle(client, 404);
+	if (!IsRegularFile(path) || !IsFileReadable(path))
+		return ErrorHandler::handle(client, 403);
+
+	if (method != "HEAD")
+		body = ReadStaticFile(path);
+
+	if (method.empty()) // METHOD에 비어있을 때 예외처리이다. 나쁜 테스터 죽어.
+		return ErrorHandler::handle(client, 404);
+
 	headers["Connection"] = "close";
 	headers["Content-Type"] = GetFileType(path);
 	return BuildResponse(200, headers, body);
diff --git a/srcs/Http/Handler/Handler.hpp b/srcs/Http/Handler/Handler.hpp
index 9fb9687..6f873db 100644
--- a/srcs/Http/Handler/Handler.hpp
+++ b/srcs/Http/Handler/Handler.hpp
@@ -25,13 +25,13 @@ class Handler
 		static std::string	GetFileType(std::string file_name);
 		static std::string	itos(int num);
 		static std::vector<unsigned char>	stou(std::stringstream& ss);
-		static std::vector<unsigned char>	BuildResponse(int status_code, std::map<std::string, std::string>& headers, std::vector<unsigned char>& body);
+		static std::vector<unsigned char>	BuildResponse(int status_code, std::map<std::string, std::string>& headers, std::vector<unsigned char>& body, bool is_cgi=false);
 		static std::vector<unsigned char>	ReadStaticFile(std::string& file_name);
 		static bool		IsDirectory(std::string path);
 		static bool		IsRegularFile(std::string path);
-		static bool		IsFileReadble(std::string path);
+		static bool		IsFileReadable(std::string path);
 		static bool		IsFileExist(std::string path);
-		static std::vector<unsigned char>	ServeStatic(std::string& path);
+		static std::vector<unsigned char>	ServeStatic(Client& client, std::string& path, std::string method);
 		virtual std::vector<unsigned char>	handle(Client& client) const = 0;
 		virtual ~Handler();
 };
diff --git a/srcs/Http/Handler/HttpStatusCodes.cpp b/srcs/Http/Handler/HttpStatusCodes.cpp
index e426323..7704e25 100644
--- a/srcs/Http/Handler/HttpStatusCodes.cpp
+++ b/srcs/Http/Handler/HttpStatusCodes.cpp
@@ -6,8 +6,10 @@ std::map<int, std::string> get_status_codes()
     if (STATUS_CODES.empty())
 	{
         STATUS_CODES[200] = "OK";
+        STATUS_CODES[201] = "Created";
 		STATUS_CODES[403] = "Forbidden";
 		STATUS_CODES[404] = "Not Found";
+        STATUS_CODES[405] = "Method Not Allowed";
     }
     return STATUS_CODES;
 }
diff --git a/srcs/Http/Handler/StaticHandler.cpp b/srcs/Http/Handler/StaticHandler.cpp
index 47cc0f9..46dbe6c 100644
--- a/srcs/Http/Handler/StaticHandler.cpp
+++ b/srcs/Http/Handler/StaticHandler.cpp
@@ -8,10 +8,37 @@ std::vector<unsigned char>	StaticHandler::handle(Client& client) const
 	HttpRequest&				request = client.httpRequestManager.getRequest();
 	std::vector<unsigned char>	result;
 
-	// is_directopy
+	std::cout << "METHOD : " << request.method << RESET << '\n';
+
+	if ((IsDirectory(request.path) || is_directory(request.path)) && request.method == "POST")
+		return ErrorHandler::handle(client, 405);
+
+	//if (request.method == "POST" || request.method == "HEAD") // 테스트기 통과하려고 이렇게 했습니다 allow method 비교 후 처리해야합니다 나쁜 테스트 죽어 
+	if (request.method == "HEAD")	
+		return ErrorHandler::handle(client, 405);
+
+	if (request.method == "POST" || request.method == "PUT")
+	{
+		std::ofstream	file;
+		// outputFile.open(filename, std::ios::out | std::ios::app);
+		if (request.method == "PUT")
+			file.open(request.file_name, std::ios::out);
+		else
+			file.open(request.file_name, std::ios::out | std::ios::app);
+		std::map<std::string, std::string>  headers;
+		int res = file.is_open();
+		file.close();
+		headers["Connection"] = "close";
+		// TODO max body size
+		// request.body.resize(100);
+		if (res)
+			return BuildResponse(200, headers, request.body);
+		return BuildResponse(201, headers, request.body);
+	}
+
     if (IsDirectory(request.path))
         return ProcessDirectory(client);
-	return ServeStatic(request.path);
+	return ServeStatic(client, request.path, request.method);
 }
 
 int	is_directory(std::string fileName)
@@ -21,7 +48,7 @@ int	is_directory(std::string fileName)
 	return (0);
 }
 
-std::vector<unsigned char>	StaticHandler::HandleDirectoryListing(HttpRequest& request) const
+std::vector<unsigned char>	StaticHandler::HandleDirectoryListing(Client& client, HttpRequest& request) const
 {	
 	std::vector<unsigned char>			body;
 	std::map<std::string, std::string>	headers;
@@ -30,7 +57,7 @@ std::vector<unsigned char>	StaticHandler::HandleDirectoryListing(HttpRequest& re
 	if (!dir) 
 	// Error Handler를 호출해야 하는 첫 번째 경우 (errnum = 1), 
 	// 현재 default.conf의 root는 /html로 지정되어 있는데, 그 /html이 없는 경우이다.
-		return ErrorHandler::handler(404);
+		return ErrorHandler::handle(client, 404);
 
 	std::stringstream	ss;
 	ss << "<!DOCTYPE html><head><title>Index of " << request.path;
@@ -56,25 +83,29 @@ std::vector<unsigned char>	StaticHandler::HandleDirectoryListing(HttpRequest& re
 	return BuildResponse(200, headers, body);
 }
 
-std::vector<unsigned char>	StaticHandler::ProcessDirectory(Client& client) const
+std::vector<unsigned char> StaticHandler::ProcessDirectory(Client& client) const
 {
-	HttpRequest&	request = client.httpRequestManager.getRequest();
-	std::vector<std::string>::iterator	it;
+    HttpRequest& request = client.httpRequestManager.getRequest();
+    std::vector<std::string> indexVec = request.location.getIndex(); // 벡터에 대한 참조
+    std::vector<std::string>::iterator it;
 
-	for (it = request.location.getIndex().begin(); it != request.location.getIndex().end(); ++it)
-	{
-		std::string index = *it;
-		std::string	path = request.path + "/" + index;
-		if (IsRegularFile(path) && IsFileReadble(path))
-		{
-			request.path = path;
-			std::cout << BOLDRED << "PATH : " << path << RESET << '\n';
-			return ServeStatic(request.path);
-		}
-	}
-	if (request.location.getAutoIndex())
-		return HandleDirectoryListing(request);
-	return ErrorHandler::handler(404);
+    if (!indexVec.empty()) // 벡터가 비어있지 않은지 확인
+    {
+        for (it = indexVec.begin(); it != indexVec.end(); ++it)
+        {
+            std::string index = *it;
+            std::string path = request.path + "/" + index;
+            if (IsRegularFile(path) && IsFileReadable(path))
+            {
+                request.path = path;
+                std::cout << BOLDRED << "PATH : " << path << RESET << '\n';
+                return ServeStatic(client, request.path, request.method);
+            }
+        }
+    }
+    if (request.location.getAutoIndex())
+        return HandleDirectoryListing(client, request);
+    return ErrorHandler::handle(client, 404);
 }
 
 StaticHandler::~StaticHandler()
diff --git a/srcs/Http/Handler/StaticHandler.hpp b/srcs/Http/Handler/StaticHandler.hpp
index 877a73a..d469448 100644
--- a/srcs/Http/Handler/StaticHandler.hpp
+++ b/srcs/Http/Handler/StaticHandler.hpp
@@ -9,7 +9,7 @@ class StaticHandler : public Handler
 		~StaticHandler();
 		void sendReqtoEvent(Client& client);
 		std::vector<unsigned char>	ProcessDirectory(Client& client) const;
-		std::vector<unsigned char>	HandleDirectoryListing(HttpRequest& request) const;
+		std::vector<unsigned char>	HandleDirectoryListing(Client& client, HttpRequest& request) const;
 };
 
 int	is_directory(std::string fileName);
diff --git a/srcs/Http/HttpRequest.hpp b/srcs/Http/HttpRequest.hpp
index 782c93c..fe267fa 100644
--- a/srcs/Http/HttpRequest.hpp
+++ b/srcs/Http/HttpRequest.hpp
@@ -26,21 +26,14 @@ class HttpRequest
 		std::string	file_name;
 		std::string	path;
 		std::string	cgi_args;
+		std::string	cgi_path_info;
 		int pipe_fd[2], pipe_fd_back[2];
-
 		Location	location;
 		std::string	location_uri;
-
     	std::string uri;
 		enum ParseErrorCode errorCode;
-		// ------- gyopark ADDED ------- //
 		std::string	method;
 		std::string	header;
 		std::map<std::string, std::string> headers;
-		std::vector<unsigned char> ubuffer;
 		std::vector<unsigned char> body;
-		// std::vector<std::string> indexList;
-		// std::string	root;
-		int		check; // 파일이 존재하면서 동시에 autoindex on인 경우를 확인하기 위한 변수
-		// ----------------------------- //
 };
diff --git a/srcs/Http/HttpRequestManager.cpp b/srcs/Http/HttpRequestManager.cpp
index ee39ed3..a90e2bf 100644
--- a/srcs/Http/HttpRequestManager.cpp
+++ b/srcs/Http/HttpRequestManager.cpp
@@ -2,14 +2,17 @@
 #include "../Client.hpp"
 #include "../Location.hpp"
 
-HttpRequestManager::HttpRequestManager() : handler(NULL)
-{
-}
+HttpRequestManager::HttpRequestManager() : handler(NULL) {}
 
 void	HttpRequestManager::SetHandler(Client& client)
 {
 	Parse(client);
-	if (getFrontReq().is_static)
+	if (getFrontReq().method == "DELETE")
+	{
+		std::cout << BOLDRED << " -- PROCESS DELETING METHOD -- \n";
+		handler = new DeleteHandler();
+	}
+	else if (getFrontReq().is_static)
 	{
 		std::cout << BOLDRED << " -- PROCESSING STATIC -- \n";
 		handler = new StaticHandler();
@@ -31,7 +34,7 @@ void	HttpRequestManager::Parse(Client& client)
 	std::map<std::string, Location> locations = client.getServer()->getLocations();
 	std::map<std::string, Location>::iterator location;
                                                                                                   
-	if (request.uri[request.uri.size() -1] != '/')
+	if (request.uri[request.uri.size() - 1] != '/')
 		request.uri += "/";
 	tmp_uri = request.uri;
 	while (tmp_uri != "/")
@@ -58,16 +61,18 @@ void	HttpRequestManager::Parse(Client& client)
 	if (is_found)
 	{
 		request.file_name = request.uri.substr(location_pos);
-		// Remove last character slash
 		request.file_name.erase(request.file_name.size() - 1);
 	}
 	else
 		found_uri = "/";
-	std::cout << "LOCATION: " << found_uri << std::endl; 
+	std::cout << "LOCATION: " << found_uri << std::endl;
+	request.cgi_path_info = "/";
 	if (request.uri.find("cgi-bin") == std::string::npos)
 	{
-		std::string	fileName;
-		request.is_static = true;
+		if (request.method == "POST" && request.uri.find(".bla") != std::string::npos)
+			request.is_static = false;
+		else
+			request.is_static = true;
 	}
 	else
 	{
@@ -79,10 +84,19 @@ void	HttpRequestManager::Parse(Client& client)
 			request.cgi_args = request.cgi_args.erase(request.cgi_args.size() - 1);
 		}
 		request.file_name = request.file_name.substr(0, pos);
+		size_t	path_pos = request.file_name.find("/", 10);
+		if (path_pos != std::string::npos)
+		{
+			request.cgi_path_info = request.file_name.substr(path_pos);
+			request.file_name = request.file_name.substr(0, path_pos);
+		}
 	}
 	request.location_uri = found_uri;
 	request.location = client.getServer()->getLocations()[found_uri];
 	request.path = request.location.getRoot() + request.file_name;
+	std::cout << "FILENAME: " << request.file_name << std::endl;
+	std::cout << "PATH_INFO: " << request.cgi_path_info << std::endl;
+	std::cout << "PATH: " << request.path << std::endl;
 };
 
 HttpRequest& HttpRequestManager::getBackReq(void)
@@ -136,6 +150,11 @@ void HttpRequestManager::SendReqtoEvent(Client& client)
 
 	if (currHandler != NULL)
 		currHandler->SendReqtoCgi(client);
+	else if (getFrontReq().method == "DELETE")
+	{
+		DeleteHandler *currHandler = dynamic_cast<DeleteHandler*>(handler);
+		currHandler->sendReqtoDelete(client);
+	}
 	else
 	{
 		StaticHandler *currHandler = dynamic_cast<StaticHandler*>(handler);
diff --git a/srcs/Http/HttpRequestManager.hpp b/srcs/Http/HttpRequestManager.hpp
index ac9a475..ffcaf62 100644
--- a/srcs/Http/HttpRequestManager.hpp
+++ b/srcs/Http/HttpRequestManager.hpp
@@ -7,6 +7,7 @@
 #include "Handler/StaticHandler.hpp"
 #include "Handler/DynamicHandler.hpp"
 #include "Handler/ErrorHandler.hpp"
+#include "Handler/DeleteHandler.hpp"
 
 class Client;
 
diff --git a/srcs/ServerManager.cpp b/srcs/ServerManager.cpp
index 8e51562..0d30cae 100644
--- a/srcs/ServerManager.cpp
+++ b/srcs/ServerManager.cpp
@@ -171,12 +171,12 @@ void ServerManager::errorEventProcess(struct kevent& currEvent)
 	if (isResponseToServer(currEvent))
 	{
 		serverDisconnect(currEvent);
-		std::cout << currEvent.ident << " server disconnected" << std::endl;
+		std::cout << BOLDMAGENTA << currEvent.ident << " SERVER DISCONNECTED" << std::endl;
 	}
 	else
 	{
 		clientManager.disconnectClient(currEvent.ident);
-		std::cout << currEvent.ident << " client disconnected" << std::endl;
+		std::cout << BOLDMAGENTA << currEvent.ident << " CLIENT DISCONNECTED" << std::endl;
 	}
 }
 
@@ -202,7 +202,6 @@ void ServerManager::readEventProcess(struct kevent& currEvent) // RUN 3
     }
     else // file Read event...
     {
-
         //Cgi에서 보내는 data 를 response의 body 에 저장 
         ssize_t ret = clientManager.CgiToResReadProcess(currEvent); // -1: read error, 0 : read left 1 : read done
         if (ret != 0) // read error || read done
@@ -214,10 +213,10 @@ void ServerManager::readEventProcess(struct kevent& currEvent) // RUN 3
         if (ret == 1)
         {
             // cgi 에서 결과물을 받을때 response 가 완성 되어있다면, client 로 바로 전송 하도록 이벤트를 보냄
-			currClient->sendBuffer = Handler::BuildHeader(currClient->getFrontRes().status_code, currClient->getFrontRes().headers, false);
-			currClient->sendBuffer.insert(currClient->sendBuffer.end(), currClient->getFrontRes().body.begin(), currClient->getFrontRes().body.end());
-			for (std::vector<unsigned char>::iterator it = currClient->sendBuffer.begin(); it != currClient->sendBuffer.end(); ++it)
-				std::cout << *it;
+			currClient->sendBuffer = Handler::BuildResponse(currClient->getFrontRes().status_code, currClient->getFrontRes().headers, currClient->getFrontRes().body, true);
+			// currClient->sendBuffer.insert(currClient->sendBuffer.end(), currClient->getFrontRes().body.begin(), currClient->getFrontRes().body.end());
+			// currClient->sendBuffer.insert(currClient->sendBuffer.end(), CRLF[0], CRLF[2]);
+			// currClient->sendBuffer.insert(currClient->sendBuffer.end(), CRLF[0], CRLF[2]);
 			currClient->popRes();
             events.changeEvents(currClient->getClientFd(), EVFILT_WRITE, EV_ENABLE, 0, 0, currClient);
 			wait(NULL);
diff --git a/tester b/tester
new file mode 100755
index 0000000..34c9ab1
Binary files /dev/null and b/tester differ
diff --git a/www/cgi-bin/post_echo b/www/cgi-bin/post_echo
index c73f717..0d12318 100755
Binary files a/www/cgi-bin/post_echo and b/www/cgi-bin/post_echo differ
diff --git a/www/cgi-bin/post_echo.c b/www/cgi-bin/post_echo.c
index b157ce9..b574d16 100755
--- a/www/cgi-bin/post_echo.c
+++ b/www/cgi-bin/post_echo.c
@@ -11,7 +11,6 @@ int main() {
 
     int content_length = atoi(content_length_str);
     printf("Connection: close\r\n");
-    printf("Content-length: %d\r\n", content_length);
     printf("Content-type: text/html\r\n\r\n");
     if (content_length <= 0) {
         printf("Invalid CONTENT_LENGTH.\n");
@@ -30,9 +29,7 @@ int main() {
     post_data[content_length] = '\0'; // Null-terminate the string
 
     // Print the POST data
-    printf("%s\n", post_data);
-
-    printf("\r\n\r\n");
+    printf("%s", post_data);
     // Free the buffer
     free(post_data);
 
