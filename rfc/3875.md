# The Common Gateway Interface (CGI) Version 1.1

# 소개
## 목적
CGI는 HTTP서버와 CGI 스크립트가 클라이언트 요청에 대응하는 역할을 공유하도록 만듭니다.
클이언트 요청은 URI, 요청 Method, 그리고 전송 프로토콜에 의해 제공된 요청에 대한 다양한 부가 정보를 포함합니다.

CGI는 CGI 스크립트와 HTTP 서버 사이의 플랫폼 독립적인 인터페이스를 명시합니다.

HTTP 서버는 클라이언트 요청에 관련된 연결, 데이터 전송, 전송 및 네트워크 문제를 관리하는 반면,
CGI 스크립트는 데이터 접근과 문서 처리와 같은 애플리케이션 문제를 처리합니다.

## 요구사항
RFC 2119 참고.

## 명세서
CGI의 모든 기능과 특징이 이 명세서에 명세 되어있지 않습니다.
다음 구문은 명시되지 않은 특징들을 설명하는 데 사용됩니다:
- 시스템-정의 (system-defined)
시스템 간에 특성은 다를 수 있지만, 동일한 시스템을 사용하는 구현체는 동일해야 합니다.
시스템은 일반적으로 운영체제로 구분 됩니다.
일부 시스템은 이 문서의 7절에서 정의됩니다. 새로운 시스템은 이 문서를 수정하지 않고 새로운 사용으로 정의될 수 있습니다.

- 구현-정의 (implementation-defined)
특징의 행동은 구현체마다 다를수 있습니다.
특정 구현는 그 행동을 문서화 해야 합니다.

## 용어
이 명세서에서는 HTTP/1.1 명세서에서 정의된 많은 용어를 사용하나, 이 문서에서 사용되는 용어는 아래와 같습니다.
- 메타-변수 (meta-variable)
서버에서 스크립트로 정보를 전달하는 명명된 매개변수입니다. 대부분의 경우 운영 체제의 환경 변수이지만, 아닌 경우도 있습니다.
> 메타변수는 스크립트에 전달되는 정보를 나타내는 변수이다.
> 이 변수들은 HTTP 서버로부터 받은 요청 정보를 나타내며, 스크립트가 이를 통해 클라이언트 요청에 대한 상세 정보를 알 수 있다.
> 클라이언트가 다음과 같은 요청을 했다고 가정해보자.
> http://example.com/cgi-bin/script.pl/additional/path?query=hello
> SCRIPT_NAME: CGI 스크립트의 경로를 나타낸다 ("/cgi-bin/script.pl")
> QUERY_STRING: 클라이언트 요청 뒤에서 "?" 문자 뒤에 오는 쿼리 문자열: ("query=hello")
> PATH_INFO: 스크립트 이름 뒤에 오는 추가 경로 ("/cgi-bin/scrip.pl/additional/path")
> SERVER_NAME, SERVER_PORT: 요청 받은 서버의 이름과 포트 번호

- 스크립트 (script)
CGI에 따라 서버가 호출하는 소프트웨어입니다. 스크립트는 반드시 독립적인 프로그램일 필요는 없으며, 동적으로 로드되거나 공유 라이브러리일 수 있고, 심지어 서버 내의 서브루틴을 수도 있습니다. 
'스크립트 (script)'라는 용어는 런타임에 실행되는 코드를 의미할 뿐만 아니라, 더 넓은 의미를 갖고 있습니다.

- 서버 (server)
클라이언트의 요청을 서비스하기 위해 스크립트를 호출하는 응용 프로그램입니다.

# 표기법 (Convention)과 일반 문법
이 부분은 일반적인 내용을 포함 하므로, 생략 하도록 하겠습니다.

# 스크립트 실행
## 서버의 역할
서버는 애플리케이션 게이트웨이 역할을 합니다. 클라이언트로부터 요청을 받아, 해당 요청을 처리하기 위핸 CGI 스크립트를 선택하고,
클라이언트 요청을 CGI 요청으로 변환한 후 스크립트를 실행하고, CGI 응답을 클라이언트 응답으로 변환합니다.
클라이언트 요청을 처리하는 동안에는 프로토콜이나 전송 수준의 인증 및 보안을 구현하는 책임이 있습니다.
서버는 또한 '비투명'방식으로 동작하여 요청이나 응답을 수정함으로써 미디어 유형 변환이나 프로토콜 축소와 같은 추가적인 서비스를 제공할 수 있습니다.

서버는 이 명세서에 의해 요구되는 클라이언트 요청 데이터에 대한 변환과 프로토콜 변환을 수행해야 합니다.
CGI 스크립트가 이 사양서를 준수하지 않더라도, 서버는 클라이언트에 대한 사양을 준수 해야 합니다.

서버에 특정 Request에 인증 기능을 적용하는 경우, 해당 Request가 접근제어를 통과하지 못한다면 스크립트를 실행할수 없습니다.

## 스크립트 선택
서버는 클라이언트가 제공한 URI에 기반하여 실행할 CGI 스크립트를 결정합니다. 이 URI에는 "/"로 구분된 구성 요소를 포함하는 계층적 경로가 포함되어 있습니다. 특정 요청에 대해, 서버는 이 경로의 전체 또는 주요 부분을 개별 스크립트와 연결합니다. 경로의 나머지 부분이 있는 경우, 이 나머지 부분은 스크립트에 의해 해석되는 리소스 또는 하위 리소스 식별자입니다.

이 경로 분할에 대한 정보는 아래에서 설명하는 메타변수를 통해 스크립트에 제공됩니다.
비계층적 URI 스키마에 대한 지원은 이 사양서의 범위를 벗어납니다.

## 스크립트 URI
클라이언트 요청 URI에서 스크립트 선택은 특정 서버 구현 및 설정에 의해 정의됩니다. 서버는 여러 다른 URI 경로 계층구조를 통해 스크립트를 식별할수 있으며, 메타변수의 처리 및 생성 동안 URI를 다른 멤버로 교체할 수 있습니다.
서버는
1. 특정 클라이언트 요청에서 URI를 유지할 수 있거나,
2. 여러 스크립트에 대한 가능한 값들 중에서 캐노니컬 URI를 선택하거나,
3. 다른 URI 선택을 구현할 수 있습니다.
이렇게 생성된 메타변수로부터, '스크립트-URI'라는 URI를 구성할수 있습니다. 클라이언트가 이 URI에 접근했다면, 스크립트는 SCRIPT_NAME, PATH_INFO 및 QUERY_STRING 메타변수에 대해 동일한 값을 가지고 실행 되어야 합니다. 스크립트-URI는 RFC 2396의 섹션 3에서 정의된 일반적인 URI의 구조를 가지며, 객체 매개변수와 Fragment 식별자는 허용되지 않습니다.

> Fragment 식별자란, #으로 시작하는 식별자로, 예를 들어 
> https://example.com/page#section1
> 이다. Fragment 식별자는 클라이언트에서 처리 되어야 한다.

스크립트-URI의 각 구성 요소는 메타변수 중 일부에 의해 정의 됩니다.
```
script-URI = <scheme> "://" <server-name> ":" <server-port> <script-path> <extra-path> "?" <query-string>
```

`<scheme>`은 SERVER_PROTOCOL에서 찾아지며, `<server-name>`, `<server-port>`와 `<query-string>`은 각각의 메타변수의 값입니다.
`SCRIPT_NAME`과 `PATH_INFO`값들은 URL 인코딩되어 있으며, `;`, `=` 그리고 `?` 예약되어 잇습니다. 이들은 `<script-path>`와 `<extra-path>`를 제공합니다.

> URL 인코딩은 데이터를 해석하는 시스템에서 잘못 이해될 가능성이 있는 경우 자주 사용된다.
> URL은 인터넷을 통해 전송될때 ASCII 인코딩을 사용해야 한다.
> URL에 ASCII 이외의 문자를 포함하는 경우 인코딩을 해야한다.
> `Hello, World`라는 문자열의 경우, 안전하지 않은 공백을 포함하고 있다.
> 이를 ISO-8859-1 인코딩에서 문자 값을 나타내는 두 개의 16진수 숫자와, `%`를 사용해 대체한다.
> 공백은 `%20`으로 대체될 수 있다.
> 따라서 `Hello, World`는 `Hello%2C%20World%21`로 인코딩 된다.

`PATH_INFO`메타변수에 대한 자세한 정보는 4.1.5 섹션을 참조하십시오.

이하 생략

## 실행
스크립트는 시스템이 정의한 방식으로 호출됩니다. 별도로 지정하지 않는 한,
스크립트가 담긴 파일은 실행 가능한 파일입니다.
서버는 섹션 4에서 명시된 대로 CGI 요청을 준비합니다.
이 요청은 메타변수(스크립트 실행시 즉시 사용 가능)와 요청 메시지 데이터를 포함합니다.
요청 데이터는 스크립트에서 즉시 사용 가능할 필요는 없습니다.
스크립트는 서버가 클라이언트로부터 모든 데이터를 수신하기 전에 실행될 수 있습니다.
스크립트로부터의 응답은 섹션 5와 6에서 설명한 대로 서버로 반환됩니다.

오류 상황이 발생하면, 서버는 언제든지 경고 없이 스크립트 실행을 중단하거나 종료할 수 있습니다. 예를 들어, 서버와 클라이언트 간의 전송 실패가 발생한 경우에 이런 상황이 발생할 수 있으므로, 스크립트는 비정상 종료를 처리할 준비가 되어 있어야 합니다.

# 4. CGI 요청
요청에 대한 정보는 두가지 출처로부터 얻어집니다; 요청 메타변수와 관련 메시지 본문입니다.

# 4.1. 요청 메타변수
메타변수는 서버로부터 스크립트에 전달된 요청에 대한 데이터를 포함하며, 
시스템이 정의한 방식으로 스크립트에 의해 접근됩니다. 메타변수는 대소문자 구분 없이 식별되며,
대소문자만 다른 같은 변수 두 개가 존재할 수 없습니다.
여기서는 대문자와 밑줄(`_`)을 사용한 표준 표현을 보여줍니다.
특정 시스템은 다른 표현을 정의할 수 있습니다.

```
메타변수 이름 = "AUTH_TYPE" | "CONTENT_LENGTH" |
                       "CONTENT_TYPE" | "GATEWAY_INTERFACE" |
                       "PATH_INFO" | "PATH_TRANSLATED" |
                       "QUERY_STRING" | "REMOTE_ADDR" |
                       "REMOTE_HOST" | "REMOTE_IDENT" |
                       "REMOTE_USER" | "REQUEST_METHOD" |
                       "SCRIPT_NAME" | "SERVER_NAME" |
                       "SERVER_PORT" | "SERVER_PROTOCOL" |
                       "SERVER_SOFTWARE" | scheme |
                       protocol-var-name | extension-var-name
  protocol-var-name  = ( protocol | scheme ) "_" var-name
  scheme             = alpha *( alpha | digit | "+" | "-" | "." )
  var-name           = token
  extension-var-name = token
```

스키마와 동일한 이름을 가진 메타변수와 프로토콜 또는 스키마 이름으로 시작하는 이름 (HTTP_ACCEPT)도 정의 됩니다.
서버는 추가적으로 `X_`로 시작하는 구현 정의 확장 메타변수를 설정할 수 있습니다.

이 명세는 길이가 0(NULL)인 값과 누락된 값을 구별하지 않습니다.
```
http://host/script 와 http://host/script?
```
이 경우 QUERY_STRING의 메타변수는 모두 NULL이 될 것 입니다.
```
메타변수-값 = "" | 1*<TEXT, CHAR or tokens of value>
```
값이 NULL인 경우 선택적인 메타변수는 생략(미설정)될 수 있습니다.
메타변수의 값은 대소문자를 구분합니다.
메타변수의 문자들의 인코딩은 시스템이 정의하며, 서버는 값을 해당 인코딩으로 처리해야 합니다.

